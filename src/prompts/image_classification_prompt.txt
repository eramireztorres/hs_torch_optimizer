You are provided with the following Python model that implements a convolutional neural network (CNN) for image classification using PyTorch:

{current_model_code}

Classification metrics for this model are:
{metrics_str}

Previous models and their performance metrics are:
{history_str}

Additional Information:
{extra_info}

Task:
Based on the given model and its performance, suggest improvements. You may either:
    - Adjust the architecture of the CNN (e.g., add more layers, change the kernel size, modify activation functions).
    - Adjust the hyperparameters of the CNN, such as the number of filters or learning rate.
    - Propose techniques to improve model generalization, such as data augmentation or regularization methods.
    - Introduce advanced techniques like batch normalization, dropout, or residual connections.

**Example 1** (Strong Metrics, Small Adjustment in Filters):
Previous Model:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)
            self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(64 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = F.relu(self.fc1(x))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

Metrics:
    Global:
        Accuracy: 0.92
        Precision: 0.91
        Recall: 0.91
        F1 Score: 0.91
    Per-Class:
        Precision per class: [0.93, 0.88]
        Recall per class: [0.92, 0.89]
        F1 Score per class: [0.92, 0.88]

Extra Info:
Not available

Suggested Improvement:
Since the model is performing well, a small adjustment to the number of filters may improve accuracy:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 64, kernel_size=3, stride=1, padding=1)  # Increased filter size
            self.conv2 = nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1)  # Increased filter size
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(128 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = F.relu(self.fc1(x))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

**Example 2** (Add Dropout to Prevent Overfitting):
Previous Model:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)
            self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(64 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = F.relu(self.fc1(x))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

Metrics:
    Global:
        Accuracy: 0.88
        Precision: 0.87
        Recall: 0.87
        F1 Score: 0.87
    Per-Class:
        Precision per class: [0.90, 0.84]
        Recall per class: [0.88, 0.83]
        F1 Score per class: [0.89, 0.83]

Extra Info:
Not available

Suggested Improvement:
Add dropout layers to prevent overfitting and improve generalization:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)
            self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(64 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
            self.dropout = nn.Dropout(0.5)  # Add dropout
        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = self.dropout(F.relu(self.fc1(x)))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

**Example 3** (Data Augmentation):
Previous Model:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)
            self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(64 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
        def forward(self, x):
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = F.relu(self.fc1(x))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

Metrics:
    Global:
        Accuracy: 0.85
        Precision: 0.85
        Recall: 0.85
        F1 Score: 0.85
    Per-Class:
        Precision per class: [0.87, 0.83]
        Recall per class: [0.85, 0.80]
        F1 Score per class: [0.86, 0.81]

Extra Info:
The training set is relatively small and lacks diversity.

Suggested Improvement:
Use data augmentation to expand the diversity of the training data:
def load_model(X_train, y_train):
    import torch.nn as nn
    import torch.nn.functional as F
    from torchvision import transforms
    class SimpleImageClassificationNN(nn.Module):
        def __init__(self, num_channels, img_height, img_width, num_classes=10):
            super(SimpleImageClassificationNN, self).__init__()
            self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)
            self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
            self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
            self.fc1 = nn.Linear(64 * (img_height // 4) * (img_width // 4), 128)
            self.fc2 = nn.Linear(128, num_classes)
            self.transform = transforms.Compose([  # Adding data augmentation
                transforms.RandomHorizontalFlip(),
                transforms.RandomRotation(10),
                transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2)
            ])
        def forward(self, x):
            x = self.transform(x)
            x = self.pool(F.relu(self.conv1(x)))
            x = self.pool(F.relu(self.conv2(x)))
            x = x.view(x.size(0), -1)
            x = F.relu(self.fc1(x))
            x = self.fc2(x)
            return x
    num_channels = X_train.shape[1]
    img_height = X_train.shape[2]
    img_width = X_train.shape[3]
    num_classes = len(set(y_train))
    return SimpleImageClassificationNN(num_channels, img_height, img_width, num_classes)

Please ensure all necessary imports are included within the function.
Provide only executable Python code for the improved model without any comments, explanations, or markdown formatting.

Output:
Provide only the improved Python code that can replace the current model.

